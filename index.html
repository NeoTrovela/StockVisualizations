<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>FAANG Interactive Explorer</title>
  <style>
    :root {
      --bg: #f7f9fb;
      --panel: #ffffff;
      --muted: #64748b;
      --accent: #2563eb;
      --grid: rgba(148, 163, 184, 0.3);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Inter", "Segoe UI", -apple-system, system-ui, sans-serif;
      color: #0f172a;
      background: var(--bg);
      min-height: 100vh;
    }

    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 28px 20px 60px;
    }

    .hero {
      display: grid;
      grid-template-columns: 1.3fr 1fr;
      gap: 24px;
      align-items: center;
      margin-bottom: 18px;
    }

    .eyebrow {
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--muted);
      font-size: 12px;
      margin-bottom: 6px;
    }

    h1 {
      margin: 0;
      font-size: 32px;
      letter-spacing: -0.02em;
    }

    p {
      margin: 10px 0;
      color: #1f2937;
      line-height: 1.6;
    }

    .pill-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
    }

    .pill {
      background: #e2e8f0;
      border: 1px solid #cbd5e1;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: #0f172a;
    }

    .hero-card {
      background: var(--panel);
      border: 1px solid #e2e8f0;
      padding: 16px 18px;
      border-radius: 10px;
      box-shadow: 0 6px 16px rgba(15, 23, 42, 0.08);
    }

    .hero-card h3 {
      margin: 4px 0 8px;
      font-size: 18px;
    }

    .hero-list {
      margin: 0;
      padding-left: 18px;
      color: #1f2937;
      line-height: 1.5;
    }

    .layout {
      display: grid;
      grid-template-columns: 260px 1fr;
      gap: 16px;
      align-items: start;
    }

    #controls {
      background: var(--panel);
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 16px;
      position: sticky;
      top: 16px;
    }

    #controls h3 {
      margin: 4px 0 10px;
      font-size: 18px;
    }

    .chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 12px;
      background: #f1f5f9;
      padding: 6px 10px;
      border: 1px solid #e2e8f0;
      cursor: pointer;
      font-size: 13px;
      transition: background-color 150ms ease, border-color 150ms ease, transform 120ms ease, box-shadow 150ms ease;
    }

    .chip input { display: none; }

    .chip span {
      font-weight: 600;
    }

    .chip.active {
      background: #dbeafe;
      border-color: #2563eb;
      box-shadow: 0 6px 14px rgba(37, 99, 235, 0.15);
      animation: selectPulse 140ms ease-out;
    }

    @keyframes selectPulse {
      from { transform: scale(0.98); }
      to { transform: scale(1); }
    }

    .summary {
      margin-top: 12px;
      padding: 10px;
      border-radius: 8px;
      background: #f8fafc;
      color: #0f172a;
      line-height: 1.5;
      font-size: 14px;
    }

    .control-label {
      margin: 14px 0 6px;
      font-weight: 600;
      font-size: 13px;
      color: #0f172a;
    }

    .date-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .date-row input {
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #cbd5e1;
      font-size: 13px;
      color: #0f172a;
      background: #ffffff;
    }

    .note {
      margin-top: 10px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.5;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      background: #2563eb;
      border: 1px solid #1d4ed8;
      border-radius: 8px;
      color: #ffffff;
      font-weight: 600;
      cursor: pointer;
      transition: background 120ms ease, transform 120ms ease;
    }

    .btn.secondary {
      background: #e2e8f0;
      border-color: #cbd5e1;
      color: #0f172a;
    }

    .btn:hover { transform: translateY(-1px); }

    #viz-area {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .chart-card {
      background: var(--panel);
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 12px 12px 4px;
      box-shadow: 0 6px 16px rgba(15, 23, 42, 0.08);
    }

    .chart-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      padding: 4px 8px 8px;
    }

    .chart-title h2 {
      margin: 2px 0 0;
      font-size: 20px;
      letter-spacing: -0.01em;
    }

    .grid-two {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }

    svg {
      width: 100%;
      background: #ffffff;
      border-radius: 8px;
      overflow: visible;
    }

    .axis path, .axis line {
      stroke: var(--grid);
    }

    .axis text {
      fill: var(--muted);
      font-size: 12px;
    }

    .price-line, .overview-line {
      fill: none;
    }

    .inline-label {
      font-size: 12px;
      dominant-baseline: middle;
      pointer-events: none;
      font-weight: 600;
    }

    .focus-line {
      stroke: rgba(100, 116, 139, 0.7);
      stroke-width: 1.2px;
      stroke-dasharray: 3 3;
    }

    .hover-capture {
      fill: transparent;
      cursor: crosshair;
    }

    .tooltip {
      position: fixed;
      pointer-events: none;
      background: #ffffff;
      border: 1px solid #e2e8f0;
      color: #0f172a;
      padding: 10px 12px;
      border-radius: 8px;
      box-shadow: 0 10px 30px rgba(15, 23, 42, 0.12);
      font-size: 13px;
      opacity: 0;
      transition: opacity 80ms ease;
    }

    .tooltip-date {
      font-weight: 700;
      margin-bottom: 4px;
    }

    .tooltip-row {
      display: flex;
      align-items: center;
      gap: 6px;
      line-height: 1.4;
    }

    .legend {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 12px;
      padding: 0 8px 8px;
    }

    .legend span {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .legend .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
    }

    .axis-label {
      fill: #cbd5e1;
      font-size: 12px;
    }

    .empty {
      fill: #cbd5e1;
      font-size: 14px;
    }

    @media (max-width: 1024px) {
      .hero {
        grid-template-columns: 1fr;
      }
      .layout {
        grid-template-columns: 1fr;
      }
      .grid-two {
        grid-template-columns: 1fr;
      }
      #controls {
        position: static;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <header class="hero">
      <section>
        <p class="eyebrow">Assignment 3 - Interactive Visualization</p>
        <h1>FAANG Stock Explorer</h1>
        <p>Ian Evensen and Neo Trovela-Villamiel</p>
        <p>CS333 - Fall 2025</p>
        <p>Implements dynamic queries and brushing+linking for FAANG stock data</p>
        <p>Perfect for data exploration and analysis</p>
      </section>
    </header>

    <article class="layout">
      <aside id="controls">
        <h3>Filters</h3>
        <form id="controls-form">
          <fieldset style="border: none; padding: 0; margin: 0;">
            <legend style="display: none;">Company Selection</legend>
            <nav id="company-picker" class="chip-row" aria-label="Company selection"></nav>
          </fieldset>
          
          <nav style="margin-top: 12px; display: flex; gap: 8px; flex-wrap: wrap;" aria-label="Reset controls">
            <button type="button" id="reset-selection" class="btn secondary">Reset companies</button>
            <button type="button" id="reset-brush" class="btn secondary">Reset brush</button>
          </nav>
          
          <fieldset style="border: none; padding: 0; margin-top: 12px;">
            <legend class="control-label">Date range</legend>
            <div class="date-row">
              <label for="start-date" style="display: none;">Start date</label>
              <input type="date" id="start-date" aria-label="Start date">
              <label for="end-date" style="display: none;">End date</label>
              <input type="date" id="end-date" aria-label="End date">
            </div>
          </fieldset>
          
          <fieldset style="border: none; padding: 0; margin-top: 12px;">
            <legend class="control-label">Investment amount (Default $10,000)</legend>
            <div style="display: flex; gap: 8px; align-items: center;">
              <label for="investment-amount" style="font-size: 14px; color: #64748b;">$</label>
              <input type="number" id="investment-amount" value="10000" min="100" step="100" 
                     aria-label="Investment amount in dollars"
                     style="flex: 1; padding: 6px 8px; border-radius: 6px; border: 1px solid #cbd5e1; font-size: 13px; color: #0f172a; background: #ffffff;">
            </div>
            <p class="note">Enter how much you would invest</p>
          </fieldset>
        </form>
        
        <section class="summary" id="summary" aria-live="polite"></section>
      </aside>

      <main id="viz-area">
        <figure class="chart-card">
          <figcaption class="chart-title">
            <header>
              <p class="eyebrow">Prices</p>
              <h2>Close price over time</h2>
            </header>
            <nav class="legend" id="legend" aria-label="Chart legend"></nav>
          </figcaption>
          <svg id="price-chart" role="img" aria-label="Price chart showing closing prices over time"></svg>
          <p style="margin: 6px 0 4px 8px;" class="eyebrow">Overview · brush to filter</p>
          <svg id="overview-chart" role="img" aria-label="Overview chart with brush selection"></svg>
        </figure>

        <section class="grid-two">
          <!-- ******************TODO: NORMALIZED PRICE CHART (Left Chart)************************** -->
          <!-- 
               All stocks start at 100 -> shows relative % growth
               Helps a lot with easy comparison -> which stock performed best?
          -->
          <figure class="chart-card">
            <figcaption class="chart-title">
              <header>
                <p class="eyebrow">Performance</p>
                <h2>Normalized Price (Indexed to 100)</h2>
              </header>
            </figcaption>
            <svg id="normalized-chart" role="img" aria-label="Normalized price chart showing percent changes"></svg>
          </figure>

          <!-- ******************TODO: VOLATILITY CHART (Right Chart)************************** -->
          <!-- 
               Bars showing daily high-low range
               Shows which stocks are riskier/more stable
          -->
          <figure class="chart-card">
            <figcaption class="chart-title">
              <header>
                <p class="eyebrow">Risk</p>
                <h2>Price Volatility from High to Low</h2>
              </header>
            </figcaption>
            <svg id="volatility-chart" role="img" aria-label="Volatility chart showing daily price ranges"></svg>
          </figure>
        </section>

        <!-- ******************TODO: CORRELATION HEATMAP (OPTIONAL)************************** -->
        <!-- 
             Grid showing which stocks move together
        -->
      </main>
    </article>
  </div>

  <aside id="tooltip" class="tooltip" role="tooltip" aria-hidden="true"></aside>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
    const companies = [
      { name: "Apple", file: "data/Apple.csv" },
      { name: "Amazon", file: "data/Amazon.csv" },
      { name: "Google", file: "data/Google.csv" },
      { name: "Facebook", file: "data/Facebook.csv" },
      { name: "Netflix", file: "data/Netflix.csv" }
    ];

    const color = d3.scaleOrdinal()
      .domain(companies.map(d => d.name))
      .range(["#555555", "#FF9900", "#34A853", "#1877F2", "#E50914"]);

    const parseDate = d3.timeParse("%Y-%m-%d");
    const fmtDate = d3.timeFormat("%b %d, %Y");
    const fmtInput = d3.timeFormat("%Y-%m-%d");

    const priceSvg = d3.select("#price-chart");
    const overviewSvg = d3.select("#overview-chart");
    // const volumeSvg = d3.select("#volume-chart");
    // const scatterSvg = d3.select("#scatter-chart");
    const normalizedSvg = d3.select("#normalized-chart");
    const volatilitySvg = d3.select("#volatility-chart");
    // const heatmapSvg = d3.select("#heatmap-chart"); if we decide to add a heatmap
    const tooltip = d3.select("#tooltip");
    const startInput = d3.select("#start-date");
    const endInput = d3.select("#end-date");
    const investmentInput = d3.select("#investment-amount");

    // ******************TODO: ADD NEW SVG SELECTIONS**************************
    // Add d3 selections for new SVG elements
    // Copy the pattern -> (const name = d3.select("#id"))
    // Done above

    let allRows = [];
    let dataExtent = null;
    let overviewBrush = null;
    let overviewX = null;
    let state = {
      selected: new Set(companies.map(d => d.name)),
      range: null,
      investmentAmount: 10000
    };

    // Load CSVs and boot the UI.
    Promise.all(
      companies.map((c) =>
        d3.csv(c.file, (d) => ({
          company: c.name,
          date: parseDate(d.Date),
          open: +d.Open,
          high: +d.High,
          low: +d.Low,
          close: +d.Close,
          adjClose: +d["Adj Close"],
          volume: +d.Volume
        }))
      )
    ).then((results) => {
      results.forEach((rows) => {
        rows.sort((a, b) => a.date - b.date);
        let prev = null;
        rows.forEach((row) => {
          row.return = prev ? ((row.close - prev) / prev) * 100 : null;
          prev = row.close;
          allRows.push(row);
        });
      });

      dataExtent = d3.extent(allRows, (d) => d.date);
      state.range = [d3.timeYear.offset(dataExtent[1], -5), dataExtent[1]];

      initUI();
      update();
    });

    function initUI() {
      const picker = d3.select("#company-picker");
      picker
        .selectAll("label")
        .data(companies)
        .join("label")
        .attr("class", "chip")
        .each(function (d) {
          const label = d3.select(this);
          label
            .append("input")
            .attr("type", "checkbox")
            .attr("value", d.name)
            .property("checked", true)
            .on("change", function () {
              if (this.checked) {
                state.selected.add(d.name);
              } else {
                state.selected.delete(d.name);
                if (state.selected.size === 0) {
                  state.selected.add(d.name);
                  this.checked = true;
                }
              }
              updateChipStyles();
              update();
            });

          label
            .append("span")
            .text(d.name)
            .style("color", color(d.name));
        });

      d3.select("#reset-selection").on("click", () => {
        state.selected = new Set(companies.map((c) => c.name));
        picker.selectAll("input").property("checked", true);
        updateChipStyles();
        update();
      });

      d3.select("#reset-brush").on("click", () => {
        state.range = null;
        update();
      });

      startInput.on("change", onDateInputChange);
      endInput.on("change", onDateInputChange);
      
      investmentInput.on("input", function() {
        const value = +this.value;
        if (value >= 100) {  // Minimum $100 investment
          state.investmentAmount = value;
          update();
        }
      });

      window.addEventListener("resize", () => update());
      renderLegend();
      syncDateInputs();
      updateChipStyles();
    }

    function renderLegend() {
      const legend = d3.select("#legend");
      legend
        .selectAll("span")
        .data(companies)
        .join("span")
        .html(
          (d) => `<span class="dot" style="background:${color(d.name)}"></span>${d.name}`
        );
    }

    // ******************TODO: CREATE HELPER FUNCTIONS**************************
    // ADD HELPER FUNCTIONS (before update())

    function normalizeData(companyData) {
      const price = companyData[0].close;

      transformed = companyData.map(d => ({...d, close: (d.close / price) * 100}))
      return transformed;
    }

    function update() {
      const selectedRows = allRows.filter((d) => state.selected.has(d.company));
      const filteredRows = state.range
        ? selectedRows.filter(
            (d) => d.date >= state.range[0] && d.date <= state.range[1]
          )
        : selectedRows;

      updateChipStyles();
      syncDateInputs();
      updateSummary(filteredRows);
      renderPrice(filteredRows);
      renderOverview(selectedRows);
      
      // ******************TODO: CALL NEW RENDER FUNCTIONS**************************
      // Replace the commented out functions with new ones

      // renderVolume(filteredRows);  // delete 
      renderScatter(filteredRows);    // replace w/ renderVolatility
    }

    function getSeries(rows) {
      const grouped = d3.group(rows, (d) => d.company);
      return Array.from(grouped, ([name, values]) => ({
        name,
        values: values.slice().sort((a, b) => a.date - b.date)
      }));
    }

    function renderPrice(filteredRows) {
      const svg = priceSvg;
      const width = getWidth(svg.node());
      const height = 320;
      const margin = { top: 16, right: 80, bottom: 36, left: 60 };
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;

      svg.attr("width", width).attr("height", height);
      svg.selectAll("*").remove();

      const series = getSeries(filteredRows.length ? filteredRows : allRows);
      const xDomain =
        filteredRows.length > 1
          ? d3.extent(filteredRows, (d) => d.date)
          : dataExtent;
      const x = d3.scaleTime().domain(xDomain).range([margin.left, width - margin.right]);
      const yMax = d3.max(series, (s) => d3.max(s.values, (d) => d.close)) || 1;
      const yMin = d3.min(series, (s) => d3.min(s.values, (d) => d.close)) || 0;
      const y = d3
        .scaleLinear()
        .domain([yMin * 0.95, yMax * 1.05])
        .range([height - margin.bottom, margin.top]);

      const xAxis = (g) =>
        g.attr("transform", `translate(0,${height - margin.bottom})`).call(
          d3.axisBottom(x).ticks(width < 700 ? 5 : 8)
        );
      const yAxis = (g) =>
        g
          .attr("transform", `translate(${margin.left},0)`)
          .call(d3.axisLeft(y).ticks(6).tickFormat(d3.format("$,.0f")))
          .call((g) => g.select(".domain").remove());

      svg.append("g").attr("class", "axis").call(xAxis);
      svg.append("g").attr("class", "axis").call(yAxis);

      const line = d3
        .line()
        .x((d) => x(d.date))
        .y((d) => y(d.close));

      svg
        .append("g")
        .selectAll("path")
        .data(series)
        .join("path")
        .attr("class", "price-line")
        .attr("stroke", (d) => color(d.name))
        .attr("stroke-width", 2)
        .attr("opacity", (d) => (state.selected.has(d.name) ? 1 : 0.2))
        .attr("d", (d) => line(d.values));

      svg
        .append("g")
        .selectAll("text")
        .data(series)
        .join("text")
        .attr("class", "inline-label")
        .attr("x", (d) => x(d.values[d.values.length - 1].date) + 6)
        .attr("y", (d) => y(d.values[d.values.length - 1].close))
        .attr("fill", (d) => color(d.name))
        .text((d) => d.name);

      const focusLine = svg
        .append("line")
        .attr("class", "focus-line")
        .attr("y1", margin.top)
        .attr("y2", height - margin.bottom)
        .style("display", "none");

      svg
        .append("rect")
        .attr("class", "hover-capture")
        .attr("x", margin.left)
        .attr("y", margin.top)
        .attr("width", innerWidth)
        .attr("height", innerHeight)
        .on("mousemove", (event) => {
          const [mx] = d3.pointer(event, svg.node());
          const hoveredDate = x.invert(mx);
          const rows = series
            .map((s) => {
              const idx = d3.bisector((d) => d.date).center(s.values, hoveredDate);
              const point = s.values[idx];
              if (!point) return null;
              return { ...point, name: s.name };
            })
            .filter(Boolean);

          if (!rows.length) return;
          focusLine
            .style("display", "block")
            .attr("x1", mx)
            .attr("x2", mx);

          positionTooltip(renderTooltip(rows, hoveredDate), event);
        })
        .on("mouseleave", () => {
          focusLine.style("display", "none");
          tooltip.style("opacity", 0);
        });
    }

    function renderTooltip(rows, date) {
      const rowsHtml = rows
        .sort((a, b) => b.close - a.close)
        .map(
          (r) =>
            `<div class="tooltip-row"><span style="color:${color(r.name)};">●</span>${r.name}: $${r.close.toFixed(
              2
            )}</div>`
        )
        .join("");
      return `<div class="tooltip-date">${fmtDate(date)}</div>${rowsHtml}`;
    }

    function renderOverview(selectedRows) {
      const svg = overviewSvg;
      const width = getWidth(svg.node());
      const height = 110;
      const margin = { top: 8, right: 40, bottom: 24, left: 60 };

      svg.attr("width", width).attr("height", height);
      svg.selectAll("*").remove();

      const series = getSeries(selectedRows);
      const x = d3.scaleTime().domain(dataExtent).range([margin.left, width - margin.right]);
      const yMax = d3.max(series, (s) => d3.max(s.values, (d) => d.close)) || 1;
      const y = d3
        .scaleLinear()
        .domain([0, yMax * 1.05])
        .range([height - margin.bottom, margin.top]);

      svg
        .append("g")
        .attr("class", "axis")
        .attr("transform", `translate(0,${height - margin.bottom})`)
        .call(d3.axisBottom(x).ticks(width < 700 ? 4 : 6));

      svg
        .append("g")
        .attr("class", "axis")
        .attr("transform", `translate(${margin.left},0)`)
        .call(d3.axisLeft(y).ticks(3))
        .call((g) => g.select(".domain").remove());

      const line = d3
        .line()
        .x((d) => x(d.date))
        .y((d) => y(d.close));

      svg
        .append("g")
        .selectAll("path")
        .data(series)
        .join("path")
        .attr("class", "overview-line")
        .attr("stroke", (d) => color(d.name))
        .attr("stroke-width", 1.3)
        .attr("opacity", 0.6)
        .attr("d", (d) => line(d.values));

      overviewX = x;
      const brushMargin = margin;

      if (!overviewBrush) {
        overviewBrush = d3
          .brushX()
          .extent([
            [brushMargin.left, brushMargin.top],
            [width - brushMargin.right, height - brushMargin.bottom]
          ])
          // only fire after the user finishes brushing
          .on("end", brushed);
      } else {
        overviewBrush.extent([
          [brushMargin.left, brushMargin.top],
          [width - brushMargin.right, height - brushMargin.bottom]
        ]);
      }


      const brushG = svg.selectAll(".brush").data([null]).join("g").attr("class", "brush");
      brushG.call(overviewBrush);

      if (state.range) {
        brushG.call(overviewBrush.move, state.range.map((d) => x(d)));
      } else {
        brushG.call(overviewBrush.move, null);
      }

      function brushed(event) {
        if (!event.sourceEvent) return;
        if (!event.selection) {
          state.range = null;
        } else {
          const [x0, x1] = event.selection;
          state.range = [x.invert(x0), x.invert(x1)];
        }
        syncDateInputs();
        update();
      }
    }

    // function renderVolume(filteredRows) {
    //   const svg = volumeSvg;
    //   const width = getWidth(svg.node());
    //   const height = 260;
    //   const margin = { top: 16, right: 24, bottom: 34, left: 60 };

    //   svg.attr("width", width).attr("height", height);
    //   svg.selectAll("*").remove();

    //   const monthly = buildMonthlyVolume(filteredRows);
    //   if (!monthly.length) {
    //     svg
    //       .append("text")
    //       .attr("class", "empty")
    //       .attr("x", width / 2)
    //       .attr("y", height / 2)
    //       .attr("text-anchor", "middle")
    //       .text("No data in view");
    //     return;
    //   }

    //   const selectedKeys = Array.from(state.selected);
    //   const x = d3
    //     .scaleTime()
    //     .domain(d3.extent(monthly, (d) => d.date))
    //     .range([margin.left, width - margin.right]);

    //   const y = d3
    //     .scaleLinear()
    //     .domain([
    //       0,
    //       d3.max(monthly, (d) =>
    //         selectedKeys.reduce((sum, key) => sum + (d[key] || 0), 0)
    //       ) * 1.05
    //     ])
    //     .range([height - margin.bottom, margin.top]);

    //   svg
    //     .append("g")
    //     .attr("class", "axis")
    //     .attr("transform", `translate(0,${height - margin.bottom})`)
    //     .call(d3.axisBottom(x).ticks(width < 700 ? 4 : 7));

    //   svg
    //     .append("g")
    //     .attr("class", "axis")
    //     .attr("transform", `translate(${margin.left},0)`)
    //     .call(d3.axisLeft(y).ticks(5, "~s"))
    //     .call((g) => g.select(".domain").remove());

    //   const stack = d3.stack().keys(selectedKeys);
    //   const stacked = stack(monthly);

    //   const area = d3
    //     .area()
    //     .x((d) => x(d.data.date))
    //     .y0((d) => y(d[0]))
    //     .y1((d) => y(d[1]));

    //   svg
    //     .append("g")
    //     .selectAll("path")
    //     .data(stacked)
    //     .join("path")
    //     .attr("fill", (d) => color(d.key))
    //     .attr("opacity", 0.82)
    //     .attr("d", area);

    //   svg
    //     .append("text")
    //     .attr("class", "axis-label")
    //     .attr("x", margin.left)
    //     .attr("y", margin.top - 4)
    //     .text("Stacked volume · monthly");
    // }

    function buildMonthlyVolume(rows) {
      const selected = Array.from(state.selected);
      const monthly = d3.rollup(
        rows,
        (v) => d3.sum(v, (d) => d.volume),
        (d) => d3.timeMonth(d.date),
        (d) => d.company
      );

      const res = Array.from(monthly, ([month, companies]) => {
        const obj = { date: new Date(month) };
        selected.forEach((name) => {
          obj[name] = companies.get(name) || 0;
        });
        return obj;
      }).sort((a, b) => a.date - b.date);

      return res;
    }

    function renderScatter(filteredRows) {
      const svg = scatterSvg;
      const width = getWidth(svg.node());
      const height = 280;
      const margin = { top: 16, right: 20, bottom: 46, left: 70 };

      svg.attr("width", width).attr("height", height);
      svg.selectAll("*").remove();

      const points = filteredRows.filter((d) => d.return !== null);
      if (!points.length) {
        svg
          .append("text")
          .attr("class", "empty")
          .attr("x", width / 2)
          .attr("y", height / 2)
          .attr("text-anchor", "middle")
          .text("No data in view");
        return;
      }

      const x = d3.scaleLinear().domain(d3.extent(points, (d) => d.return)).nice()
        .range([margin.left, width - margin.right]);
      const y = d3.scaleLog().domain(d3.extent(points, (d) => d.volume)).nice()
        .range([height - margin.bottom, margin.top]);
      const r = d3.scaleSqrt().domain(d3.extent(points, (d) => d.close)).range([2.5, 9]);

      svg
        .append("g")
        .attr("class", "axis")
        .attr("transform", `translate(0,${height - margin.bottom})`)
        .call(d3.axisBottom(x).ticks(6).tickFormat((d) => `${d}%`));

      svg
        .append("g")
        .attr("class", "axis")
        .attr("transform", `translate(${margin.left},0)`)
        .call(d3.axisLeft(y).ticks(6, "~s"))
        .call((g) => g.select(".domain").remove());

      svg
        .append("g")
        .attr("fill-opacity", 0.7)
        .selectAll("circle")
        .data(points)
        .join("circle")
        .attr("cx", (d) => x(d.return))
        .attr("cy", (d) => y(d.volume))
        .attr("r", (d) => r(d.close))
        .attr("fill", (d) => color(d.company))
        .on("mousemove", (event, d) => {
          positionTooltip(
            `<div class="tooltip-date">${fmtDate(d.date)} · ${d.company}</div>
             <div class="tooltip-row">Close: $${d.close.toFixed(2)}</div>
             <div class="tooltip-row">Return: ${d.return.toFixed(2)}%</div>
             <div class="tooltip-row">Volume: ${d3.format(",")(d.volume)}</div>`,
            event
          );
        })
        .on("mouseleave", () => tooltip.style("opacity", 0));

      svg
        .append("text")
        .attr("class", "axis-label")
        .attr("x", width / 2)
        .attr("y", height - 6)
        .attr("text-anchor", "middle")
        .text("Daily return (%)");

      svg
        .append("text")
        .attr("class", "axis-label")
        .attr("transform", `rotate(-90)`)
        .attr("x", -height / 2)
        .attr("y", margin.left - 50)
        .attr("text-anchor", "middle")
        .text("Volume (log scale)");
    }

    function calculateInvestmentReturns(filteredRows) { // helper function to calculate investment returns
      const investment = state.investmentAmount; // inputted investment amount
      
      return Array.from(state.selected).map(companyName => {
        const companyData = filteredRows
          .filter(d => d.company === companyName)
          .sort((a, b) => a.date - b.date);
        
        if (companyData.length < 2) return null;
        
        const startPrice = companyData[0].close;
        const endPrice = companyData[companyData.length - 1].close;
        const sharesBought = investment / startPrice;
        const finalValue = sharesBought * endPrice;
        const profit = finalValue - investment;
        const percentReturn = ((endPrice - startPrice) / startPrice) * 100;
        
        return {
          company: companyName,
          finalValue: finalValue,
          profit: profit,
          percentReturn: percentReturn
        };
      }).filter(Boolean);
    }

    function updateSummary(filteredRows) {
      const summary = d3.select("#summary");
      const selection = Array.from(state.selected);
      const rangeText = state.range
        ? `${fmtDate(state.range[0])} - ${fmtDate(state.range[1])}`
        : "Full history";

      // get investment returns from the helper function just made
      const returns = calculateInvestmentReturns(filteredRows);
      
      // make investment returns into HTML
      const returnsHtml = returns.length > 0 ? `
        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e2e8f0;">
          <strong>$${state.investmentAmount.toLocaleString()} Investment Returns</strong>
          ${returns.map(r => `
            <div style="margin-top: 8px; padding: 8px; background: ${r.profit >= 0 ? '#d4edda' : '#f8d7da'}; border-radius: 6px; border: 1px solid ${r.profit >= 0 ? '#c3e6cb' : '#f5c6cb'};">
              <div style="font-weight: 600; color: ${color(r.company)}; margin-bottom: 4px;">${r.company}</div>
              <div style="font-size: 13px;">
                <div>Final Value: <strong>$${r.finalValue.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</strong></div>
                <div style="color: ${r.profit >= 0 ? '#155724' : '#721c24'}; font-weight: 600;">
                  ${r.profit >= 0 ? '+' : ''}$${r.profit.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})} 
                  (${r.percentReturn >= 0 ? '+' : ''}${r.percentReturn.toFixed(2)}%)
                </div>
              </div>
            </div>
          `).join('')}
        </div>
      ` : '';

      summary.html(`
        <div><strong>Companies:</strong> ${selection.join(", ")}</div>
        <div><strong>Window:</strong> ${rangeText}</div>
        <div><strong>Points in view:</strong> ${filteredRows.length.toLocaleString()}</div>
        ${returnsHtml}
      `);
    }

    function onDateInputChange() {
      const startVal = startInput.property("value");
      const endVal = endInput.property("value");
      if (!startVal || !endVal) return;
      const start = new Date(startVal);
      const end = new Date(endVal);
      if (start > end) return;
      state.range = [start, end];
      update();
    }

    function syncDateInputs() {
      if (!dataExtent) return;
      const start = state.range ? state.range[0] : dataExtent[0];
      const end = state.range ? state.range[1] : dataExtent[1];
      startInput.attr("min", fmtInput(dataExtent[0])).attr("max", fmtInput(dataExtent[1]));
      endInput.attr("min", fmtInput(dataExtent[0])).attr("max", fmtInput(dataExtent[1]));
      startInput.property("value", fmtInput(start));
      endInput.property("value", fmtInput(end));
    }

    function positionTooltip(html, event) {
      tooltip.html(html).style("opacity", 1);
      const padding = 12;
      const rect = tooltip.node().getBoundingClientRect();
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const { clientX, clientY } = event;

      let x = clientX + padding;
      if (x + rect.width + padding > vw) {
        x = clientX - rect.width - padding;
      }
      if (x < 8) x = 8;

      let y = clientY - 10;
      if (y + rect.height + padding > vh) {
        y = clientY - rect.height - padding;
      }
      if (y < 8) y = 8;

      tooltip.style("left", `${x}px`).style("top", `${y}px`);
    }

    function getWidth(svgNode) {
      if (!svgNode) return 960;
      const parent = svgNode.parentNode;
      const rect = parent.getBoundingClientRect();
      return rect.width ? rect.width : 960;
    }

    function updateChipStyles() {
      d3.select("#company-picker")
        .selectAll("label")
        .classed("active", (d) => state.selected.has(d.name));
    }
  </script>
</body>
</html>
